# < 1주차 - 컴퓨터 내부의 언어 체계 >

| 51~90p | 작성자 : `김영훈`,`도진욱`,`이주영` / 학습 기간 : *2022.02.03. ~ 2022.02.09.* |
| ------ | -----------------------------------------------------------: |


---

<br>

#### - Bit : '2진법을 사용하는(Binary)' + '숫자(Digit)'

 일상 속에서 우리가 사용하는 문자(Character)대신에, 컴퓨터에서는 Bit를 사용하고 있다. 이번 학습 내용에서는 컴퓨터를 사용한 계산 과정에서 비트에 의미를 부여하는 방법들을 배울 수 있었다.

---

<br>

### 1) 논리 연산(Logic Operation)

: 비트는 두 가지 값을 가지는데, 논리 연산에서는 '참(True, 1)'과 '거짓(False, 0)'을 가진다. 이를 사용하여 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작을 수행할 수 있는데, 이를 '논리 연산'이라고 한다.

<br>

- #### 불리언 대수(Boolean algebra)

  : 세 가지 기본적인 불리언 연산자 *'NOT, AND, OR'*을 이용한다.

  - NOT : 논리적 반대, 즉 입력값에 대한 부정값을 출력한다.
  - AND : 둘 이상의 비트에서 모두 참이어야 참을 출력, 그 외는 전부 거짓을 출력
  - OR : 둘 이상의 비트에서 모두 거짓일 때만 거짓을 출력, 그 외는 전부 참을 출력

    추가적으로, *'XOR(Exclusive OR, 배타적 논리합)'*을 배웠다.

  - XOR : 두 비트가 다를 경우(배타적인 상황)에서만 참을 출력, 그 외는 전부 거짓을 출력.

   **"a XOR b = (a OR b) AND (NOT(a AND b))"**  ✔

  <br>

- #### 드모르간의 법칙(De Morgan's law)

		 : **a AND b = NOT(NOT a OR NOT b)** ✔

---

<br>

### 2) 정수를 비트로 표현하는 방법

<br>

- #### 양의 정수 표현

> LSB : 2진수에서 가장 오른쪽의 비트, 가장 작은 유효 비트(Least Significant Bit)
>
> MSB : 2진수에서 가장 왼쪽의 비트, 가장 큰 유효 비트(Most Significant Bit)

<br>

- #### 2진수 덧셈

컴퓨터에서는 A + B 를 수행할 때, AND 결과값이 첫째자리 수, XOR 결과값이 둘째자리 수가 된다. ✔

|  A   |  B   | A AND B | **A + B** | A XOR B |  A   |  B   |
| :--: | :--: | :-----: | :-------: | :-----: | :--: | :--: |
|  0   |  0   |    0    |    00     |    0    |  0   |  0   |
|  0   |  1   |    0    |    01     |    1    |  0   |  1   |
|  1   |  0   |    0    |    01     |    1    |  1   |  0   |
|  1   |  1   |    1    |    10     |    0    |  1   |  1   |

덧셈 결과가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나는 경우를 '오버플로(Overflow)'라고 한다.

<br>

- #### 음수 표현

  - 부호와 크기(sign and magnitude)

    : 한 비트를 부호에 사용하고 나머지 비트를 수의 크기를 표현하는 표현 방법

    - 문제점 : 0을 표현하는 방법이 두 가지(+0, -0)라서 비효율적이고, AND와 XOR을 통한 덧셈 불가.

  - 1의 보수(one's complement)

    : 양수의 모든 비트를 뒤집어 표현하는 방법
  
    - 문제점 : 0을 표현하는 방법이 두 가지(+0, -0)라서 비효율적이고, 덧셈은 가능하지만 MSB쪽에서 LSB로 올림을 전달해야 하는 순환 올림(end-around-carry)을 사용해야 하므로 복잡하다.
  
  - 2의 보수(two's complement) ✔
  
    : 어떤 수의 비트를 뒤집고(각 비트에 NOT연산을 취하고), 1을 추가하면 음수를 얻을 수 있다. 이 때, MSB에서 올림이 발생하면 이 값은 버린다.
  
    : 현대 컴퓨터에서는 부호와 크기 표현법이나 1의 보수 표현을 모두 사용하지 않으며, 특별한 하드웨어를 추가하지 않고도 XOR과 AND연산만 사용해야 할 때에 사용할 수 있는 표현 방법이다.
  
    : 이전 문제점을 보완하여 0을 표현하는 방법이 하나뿐이다.


---

<br>

### 3) 실수를 표현하는 방법

<br>

- #### 고정소수점(fixed-point) 표현법

  : 4개의 비트로 수를 표현하게 되는데, 왼쪽 2비트는 정수부분, 오른쪽 2비트는 분수부분으로 가운데에 소수점이 있다고 생각하는 방법이다.

  - 문제점 : 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많다.

<br>

- #### 부동소수점(floating-point) 표현법✔

  : 가수(mantissa)부분에서는 2진 소수, 지수(exponent)부분에서는 2의 거듭제곱 횟수 표현하여 나타내는 방법이다.

  - 문제점 : 비트 조합 중에 낭비되는 부분이 많다.(동일한 수를 표현하는 다수의 방법이 존재), 비트 패턴이 가능한 모든 수를 표현하지 못한다.

- #### IEEE 부동소수점 수 표준

  : IEEE(Institute of Electrical and Electronic Engineers, 미국 전자전기공학회)에서 표준 제정.

  - 정규화 : 가수를 조정하여 맨 앞(왼쪽)에 0이 없게 만드는 것.
  - 생략 : 가수의 맨 왼쪽 비트가 1이므로 생략한다.

---

<br>

### 4) 2진 코드화한 10진수 시스템

<br>

- #### BCD(Binary-coded decimal)

  : 2진 코드화한 10진수

  - ex) 10진수인 12를 2진수로 표현하면 1100이지만, BCD로 표현하면 0001 0010 (10 + 2)과 같이 표현할 수 있다.

  인간에게 더 익숙한 방법으로 2진수를 표현할 수 있게 되는 것이다.

  디스플레이나 가속도 센서 등이 BCD를 사용하는 경우가 있다.

  - 문제점 : 같은 수를 표현할 때 더 많은 비트를 사용한다.

---

<br>

### 5) 2진수를 다루는 쉬운 방법

<br>

- #### 8진 표현법(Octal representation)

  : 밑이 8인 표현방법으로, 2진수 비트들을 3개씩 그룹으로 묶어서 2진수를 변환할 수 있다.

<br>

- #### 16진 표현법(hexadecimal representation)✔

  : 밑이 16인 표현방법으로, 2진수 비트들을 4개씩 그룹으로 묶어서 2진수를 변환할 수 있다.

  실제로, 컴퓨터에서 많이 쓰이는 표현방법이다.

| 2진수 | 16진수 | 2진수 | 16진수 |
| :---: | :----: | :---: | :----: |
| 0000  |   0    | 1000  |   8    |
| 0001  |   1    | 1001  |   9    |
| 0010  |   2    | 1010  |   a    |
| 0011  |   3    | 1011  |   b    |
| 0100  |   4    | 1100  |   c    |
| 0101  |   5    | 1101  |   d    |
| 0110  |   6    | 1110  |   e    |
| 0111  |   7    | 1111  |   f    |

<br>

- #### 프로그래밍 언어의 진법 표기법

  : 여러 프로그래밍 언어에서는 다음과 같은 표기법을 따른다.

  - 0으로 시작하는 숫자는 8진 숫자이다. ex) 017
  - 1부터 9 사이의 숫자로 시작하는 숫자는 10진수다.
  - 0x가 앞에 붙은 숫자는 16진수다. ex) 0x12f

---

<br>

### 6) 비트 그룹의 이름

- 비트의 묶음을 부르는 이름:

  |          이름          | 비트 개수 |
  | :--------------------: | :-------: |
  |      니블(nibble)      |     4     |
  |      바이트(byte)      |     8     |
  |  하프 워드(half word)  |    16     |
  |       워드(word)       |    32     |
  | 더블 워드(double word) |    64     |

---

<br>

### 7) 텍스트 표현

<br>

- #### 아스키 코드

  : 아스키 코드(ASCII : American Standard Code for Information Interchange)는 정보 교환을 위한 미국 표준 코드로, 컴퓨터가 다루는 비트를 이용하여 영어 텍스트를 표현하는 표준으로 자리잡았다.

<br>

- #### 다른 표준의 진화

  : 컴퓨터가 널리 쓰이게 됨에 따라 여러 언어의 표준이 생겨나게 되었고, 비트의 가격이 떨어짐에 따라 **'유니코드(Unicode)'**라는 새로운 표준이 만들어졌고, 문자에 16비트를 부여했다. 그 후 21비트까지 확장되었다.

<br>

- #### 유니코드 변환 형식 8비트

  -**'인코딩(encoding)'** : 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴

  -**'UTF-8 (Unicode Transformation Format-8bit)'**, 인코딩 방법 중 하나로, 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있다. 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때는 추가 공간이 필요하지 않다. 

---

<br>

### 8) 문자를 사용한 수 표현

<br>

- #### 출력 가능하게 변경한 인코딩

  -**'QP 인코딩(Quoted-Printable encoding)'** : 전자우편 첨부를 처리하기 위해 만들어졌다. 작동은 잘 되지만, 1바이트를 표현하기 위해 3바이트를 사용하므로 아주 비효율적이다.

<br>

- #### 베이스64 인코딩

  : QP 인코딩의 단점을 보완하여, 3바이트 데이터를 4문자로 표현한다. 총 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현한다.

<br>

- #### URL 인코딩

  -**'URL 인코딩( = percent-encoding)'** : '%' 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.

---

<br>

### 9) 색을 표현하는 방법

: RGB 색 모델(RGB color model)이라는 표현법을 이용해 컴퓨터 모니터는 적색, 녹색, 청색 광선을 섞어서 색을 만들어낸다.

<br>

- #### 투명도 추가

  -**'투명도(transparency)'** : 색을 투과해 볼 수 있는 정도를 뜻하며, 워드(32비트)에 색을 넣어서 처리되는 과정에서 남는 8비트(적색 값 : 8비트, 녹색 값 : 8비트, 청색 값 : 8비트를 사용하고 남는 8비트)를 투명도로 처리하여 비트를 효율적으로 사용함과 동시에 다양한 색 표현이 가능하다.

<br>

- #### 색 인코딩

  -**'16진 트리플렛(hex triplet)'** : # 뒤에 여섯자리 16진 숫자를 추가해 #rrggbb 처럼 표현하는 방식이다.

---

<br>

## 📋 이번 학습으로 인해 느낀 점 : 

-   컴퓨터가 2진수의 수 체계를 가지고 있다는 건 알고 있었는데, 이번 학습을 통해 사람인 나에게 익숙하지 않을 뿐이지, 결코 어렵진 않다는 생각이 들었다.

-  독서라고 생각하기 보다는 학습이라고 생각한다는게 좀 어색하게 느껴졌던 것 같다.

  독서는 이야기의 흐름만 알면 되지만, 학습은 나를 위해서 하나하나 놓치지 않고 깨닫는 것에 대한 정리가 확실히 필요하기 때문이다.

- 논리식은 학부 시절에 많이 다뤘었던 내용이었어서 이전보다 쉽게 학습할 수 있었던 것 같다. 그리고, '드모르간의 법칙은 정말 많이 다뤘었는데, 이것을 어떻게 응용할 것이며, 왜 사용하는 지에 대해서 항상 의문을 가지고 있었는데, 이번 학습으로 깨닫게 될 수 있었던 것 같다.

  > 드모르간의 법칙이 없다면 부정적인 논리를 구현할 때 'NOT NOT 춥다 OR NOT NOT 비가 온다'로 OR을 사용해야 했을 것이다. 물론 이런 논리도 제대로 작동하지만 **연산을 최소로 사용하면 비용을 최소화할 수 있다.** 여기서는 **NOT 연산을 수행하는 하드웨어에 실제로 돈이 들기도 하고, 연산을 연쇄적으로 사용하면 계산이 느려진다.**


- 보수부분은 이 전에 배웠었는데, 매번 헷갈렸었고 정확한 용도를 몰라서 배우기를 스스로 거부했던 것 같다. 이번 학습을 통해 보수를 어떻게 취하는지, 2의 보수가 컴퓨터의 음수 변환 연산에서 어떤 방법으로 활용되는지 제대로 알게 된 것 같다.

-   수학과목을 배우는 것 같으면서도 영어로 된 용어를 알 수 있다는 점도 흥미롭고, 결국 전 세계 사람들이 같은 것을 공부하고 있다는 동질감까지 느낄 수 있었다.
-   짧은 시간이었지만 그동안 내가 프로그래밍을 배우는 동안, 한 번쯤 스쳐지나갔었던 단어들을 책 속에서 다시 마주하게 되니 너무 반가웠고 그동안 모르고 있었던 지식을 자세하게 알 수 있어서 좋았다.
-   개인적으로, 모든 지식을 다 담고 기억하며 살아가기엔 내 능력이 부족하다는 것을 잘 안다. 하지만, 내가 앞으로 가야할 길에 대해서 조금이라도 더 알면 좋을 것 같아서, 앞으로도 최대한 더 알아가보려고 한다. 전부 기억할 순 없더라도 어느정도는 이해하고 싶기 때문이다.